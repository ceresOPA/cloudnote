# 数据结构



## 问题篇

### 1. 最短路径

- 最短路径一般分为单源最短路径和多源最短路径，单源最短路径通常会采用迪杰斯特拉算法来进行求解，但迪杰斯特拉只能够应用于非负权值的问题上，迪杰斯特拉算法的时间复杂度为$O(n^2)$；而多源最短路径一般会采用弗罗里达算法，时间复杂度为$O(n^3)$。



### 2. 哨兵和头结点的本质作用？

- 哨兵和头结点本质上都是用来简化代码，使程序更加高效。
- 哨兵可以用来简化边界条件，在循环或者迭代中用来标志终止的值，像顺序查找中，可以让下标为0的数组位置存放本次要查找的元素值，然后从后往前，就只需要判断值是否相等，而不需要去判断当前下标来避免越界，简化了代码。
- 引入头结点后，可以让链表中第一个结点的操作与其他结点保持一致，写在一个循环里面，就比如插入的时候，就不需要单独为插入第一个结点来调整头指针了，而是可以和其他结点的操作步骤一样。



### 3. 堆排序

- 堆排序一般分为大根堆和小根堆，它的一个特点就是下一层的结点大小一定是小于上一次的，然后根结点是最大的或者最小的。
- 一般需要先建堆，然后才能够进行堆排序，自底向上建堆的时间复杂度为$O(n)$，堆排序取$n$个数，每次调整的时间为$logn$，所以堆排序的时间复杂度为$O(nlogn)$。
- 由于堆排序每次都能够确定最大或者最小的元素，因此非常适合从许多元素中选取最大或最小的一些元素的情形。



### 4. 快速排序的时间复杂度，以及如何解决快速排序最快的情形

- 快速排序的最好和平均时间复杂度为$O(nlogn)$，最坏时间复杂度为$O(n^2)$。
- 快排的效率与每次选取的枢轴有关，当每次选取的元素不能够平分两侧的话，就会影响快排的效率，如基本有序的序列，每次选取最前面的元素就会导致最坏的情况，因此只要能够选择合适的枢轴就可以解决最坏的情形，一般可以随机化选择枢轴或者从前、中、后的三个元素中选择大小中间的那个元素，这样即使是有序的情况下，也能够避免最坏的发生。



### 5. 无向图的遍历方法，时间复杂度？

- 深度优先遍历，广度优先遍历
- 时间复杂度与使用的遍历方法无关，而是与所选择的图的存储结构有关，若选择邻接矩阵作为存储结构，则时间复杂度为$O(n^2)$，若选择邻接表作为存储结构，则时间复杂度为$O(V+E)$



### 6. 无向图中两结点的最远距离怎么求？

- 可以类比最短路径，可以使用迪杰斯特拉算法，其中每次选取的是距离最长的路径，而不是最短的



### 7. 队列满空的条件

- 若采用循坏队列，用$i$表示队头，$j$表示队尾，则$(j+1)\%Len == i$表示队满，其中$Len$是循环队列的长度，而$i==j$则表示队空。
- 使用循坏队列可以避免假溢出的发生



### 8. 时间效率为$O(1)$的查找方法

- 哈希查找，哈希查找直接利用关键字访问内存存储位置。将所查找的数据映射导散列表中，其中的映射方法就是使用散列函数(或称哈希函数)
- 常用散列函数：
  - 直接定址法，取关键字或关键字的某个线性函数值为散列地址（$y = x $或 $y = kx+b$）
  - 数字分析法，取关键字的若干数位作为散列地址
  - 平方取中法，取关键字平方后的值的中间几位为散列地址，因为有时并无法判断选择关键字的哪几位比较合适，因此通过平方后的数就与原关键字的每一位都有关系，从而保证散列地址的随机性。
  - 折叠法，将关键字分为数位相同的几个部分，然后取这几部分的叠加和作为散列地址
  - 除留余数法，取关键字被某个不大于表长m的数p(一般取不大于表长的最大素数)除后的余数作为散列地址，即$hash(k) = k\%p （p<=m）$ 
- 常用处理哈希冲突的方法：
  - 拉链法
  - 开放定址法
    - 线性探测法
    - 平方探测法



### 9. 设计算法-找出图的强连通分量



### 10. 有向图可不可以有最小生成树？

- 可以，有向图的最小生成树称为 最小树形图，可以使用 朱刘算法 进行求解。



### 11. 图的边权值有负，要求最短路径，应该怎么解决？

- 因为在迪杰斯特拉算法中，已加入到最短路径中的结点是无法再进行更新的，如果在后面再出现负的权值的到该结点的路径，导致路径之和更小，则没有办法进行更新。
- Floyd算法可以解决有负权值的情形，但是当存在负环的情况下，是无法得到最短路径的，因为通过负环可以无限地小下去。



### 12. 二叉树查找的时间复杂度

- 二叉查找树，即二叉排序树，通过中序遍历即可得到一个有序序列。
- 在二叉排序树是平衡的情况下，查找的时间复杂度与树的深度有关，即$O(logn)$，当二叉排序树是一颗单子树的时候，则与顺序查找的时间复杂度一样$O(n)$。



### 13. 排序算法时间复杂度的下限

- 基数排序



### 14. 举例说明不同数据结构在算法实现时，时间复杂度不同的现象

- 最常见的例子应该就是线性表和链表的插入、删除、查找操作
- 其中对于插入与删除，链表只要找到位置，就只需要$O(1)$就能完成插入和删除；而线性表在插入操作中，删除中间某个元素，需要前移后面的元素，插入操作，需要后移后面的元素留出位置，因此线性表完成插入和删除操作需要$O(n)$的时间复杂度
- 对于查找操作，由于线性表直接通过下标就可以访问所有的元素，即时间复杂度为$O(1)$，而对于链表，需要从头结点开始往下查找，因此时间复杂度为$O(n)$。



### 15. 如何证明一个无向图是双连通的？

- 话说什么叫双连通？？



### 16. 一般树与二叉树的区别

- 二叉树是区分左右孩子的，一般树只表明有几个孩子结点，并没有左右之分。
- 二叉树的每个结点最多只能有两个结点，而一般树无限制。



### 17. 已知先序遍历和后续遍历可以确定唯一的一颗树吗？

- 不可以，无论是先序遍历还是后序遍历都只能确定根结点，而没有办法确定左右结点，要想确定一颗二叉树的话，必须要知道它的中序遍历



### 18. 给你两颗二叉树怎么确定它们的高低？

- 遍历得到树的深度，如先序遍历，递归就可以求出树的深度
- 根据树的深度就可以判断树的高低



### 19. 能用来查询的数据结构，哪种综合性能好，查询和维护都能达到$O(nlogn)$?

- 平衡二叉树
- 红黑树
- 综合来说，平衡二叉树的查找效率更高，但维护代价也更高，而红黑树的调整代价较低，查找效率会稍低一些。



## 归纳篇

### 树

1. **对于先序、中序、后序与层次遍历，怎样才能够构建一颗唯一的二叉树？**

答：只要已知中序和其他任意三种遍历中的一种就可以实现确定唯一一颗二叉树。

解析：已知先序、后序或者层次中的任意种，就可以确定这颗树的根结点；已知中序遍历，就可以知道根的左右结点；把这颗二叉树看成是多颗小二叉树，这样就可以确定好每个根结点及其左右结点，最终确定整个大二叉树的结构。

2. **如何进行二叉排序树的删除？**

答：一共三种情形：	

​		① 删除结点是叶子结点：**直接删除**就可以了，不会破坏二叉排序树的结构

​		② 删除结点有左子树或右子树：**让删除结点的父结点指向删除结点的左子树或右子树**，因为如果只有左子树，那中序遍历最后访问			的是删除的结点，如果只有右子树，那中序遍历最先访问的就是删除的结点。

​		③ 删除结点既有左子树又有右子树：让删除结点与其中序遍历的前驱或者后驱结点交换，然后删除前驱或后驱结点。

### 查找

1. **有哪些处理哈希冲突的方法？**

   拉链法：将哈希值相同的结点放在一个链表中

   线性探测法：

   平方探测法：